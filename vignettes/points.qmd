---
title: "Points"
format: 
  html:
    toc: true
vignette: >
  %\VignetteIndexEntry{points}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  dev = "ragg_png",
  comment = "#>",
  fig.width = 7,
  fig.height = 7
)
library(ggpathdiagramr)
library(ggplot2)
library(dplyr)
```

# Setup

# Packages

```{r setup}
library(ggpathdiagramr)
library(ggplot2)
library(dplyr)
library(ggtext)
```

# Base plot

To avoid repetitive code, we make a base plot:

```{r}
bp <- ggplot() + 
  coord_equal(xlim = c(0, 5),
              ylim = c(0, 5)) + 
  theme_minimal(base_size = 20, 
                base_family = "Roboto Condensed") +
  theme(axis.title.y = element_text(angle = 0, vjust = 0.5))

update_geom_defaults("richtext", 
                     list(family = 
                            "Roboto Condensed", size = .8 * 20 / ggplot2::.pt))

update_geom_defaults("point", list(size = 2.5))

```



# Points

Points have x and y coordinates. 

```{r points}
p1 <- point(1, 2)
p2 <- point(5, 4)
```

```{r}
bp +
  p1 +
  p2 +
  label(c(p1, p2), vjust = 0)

```


## Polar Coordinates

A point's x and y coordinates can be specified in polar coordinates

* `@r`: The distance from the origin to the point (i.e., the vector's magnitude)
* `@theta`: The angle (in radians) from the line on the x-axis to the line containing the vector.

```{r}
p2
p2@r
p2@theta
```


```{r}
a <- arrow_segment(p1 = p1, p2 = p2)

bp +
  p2 +
  as.geom(a, resect_head = 2) +
  label(p = midpoint(a),
        label = distance(a),
        angle = a@line@angle,
        vjust = 0)
```


A point can be created with polar coordinates

```{r}
polar(r = 5, theta = angle(degree = 60))
```

If the angle is numeric instead of an angle, it is assumed to be in radians. 

```{r}
point(r = 1, theta = pi)@theta

```


A point can be converted to a 1 &times; 2 matrix:

```{r}
p1@xy
as.matrix(p1)
```

# Methods

## Arithmetic

Points can be added and subtracted:

```{r}
p1 <- point(2, 3)
p2 <- point(2, 1)
p3 <- p1 + p2
p3
p3 - p2
```

Points can be scaled with constants

```{r}
p3 * 2
p3 / 4
```

# Distance

The distance between two points:

```{r}
distance(p1, p2)
```

The shortest distance from a point to a line:

```{r}
l1 <- line(slope = 1, intercept = 2)
distance(p1, l1)
```

The shortest distance from a point to a circle's edge:

```{r}
c1 <- circle(center = point(2, 2), radius = 2)
p1 <- c1@center + polar(r = c1@radius, theta = degree(115))
p2 <- c1@center + polar(r = c1@radius * 2, theta = degree(45))
p3 <- c1@center + polar(r = c1@radius * .3, theta = degree(190))
# p1 is on circle, so its distance is 0
distance(p1, c1)
# p2 is outside the circle
distance(p2, c1)
# p3 is inside the circle
distance(p3, c1)
distance(c1, c1@center)

pts <- point_list(c(p1, p2, p3))
intersect_c1_p2 <- anchor(c1, (p2 - c1@center)@theta)
seg_c1_p2 <- segment(p2, intersect_c1_p2)

intersect_c1_p3 <- anchor(c1, (p3 - c1@center)@theta)
seg_c1_p3 <- segment(p3, intersect_c1_p3)
bp +
  c1 +
  pts +
  label(pts, vjust = 0, label = paste0("p", seq(length(pts)))) + 
  intersect_c1_p2 +
  seg_c1_p2 +
  label(seg_c1_p2, distance(seg_c1_p2)) + 
  intersect_c1_p3 +
  seg_c1_p3 +
  label(seg_c1_p3, distance(seg_c1_p3))
  


```



```{r}
bp + 
  # xlim(-3,3) + 
  # ylim(-3,3) +
  p1


```



# Point Lists

Points can be concatenated in a list like any other object.

```{r}
c(p1, p2)
```

However, extracting properties from that list is more convenient if the list is made into a `point_list`.

```{r}
pts <- point_list(c(p1, p2, p3))
pts@x
pts@y
pts@r
pts@theta@degree
```


```{r}
ggplot() +
  coord_equal() +
  pts
```


A list of points can also be created with x and y vectors separately:

```{r}
x <- c(2, 4, 5, 0)
y <- c(0, 4, 2, 5)
pts <- point(x, y)
```

A point list can also be created directly from a two-column matrix:

```{r}
# A two-column matrix from x and y
m <- cbind(x,y)
pts <- point(m)
```



```{r}
ggplot() +
  coord_equal() +
  pts


```


## Point_list data

A `point_list` is a list, and behaves like a list should

```{r}
p1 <- point(3, 4, color = "red")
p2 <- point(2, 3, size = 6)

pts <- point_list(c(p1,p2))
pts[[1]]


```

To get just the xy coordinates, use the `@xy` property.

```{r}
pts@xy
```

To get a tibble with any style information that has been set:

```{r}
get_tibble(pts)
```

To get the same tibble, but with any missing style information filled with defaults:

```{r}
get_tibble_defaults(pts)
```

# Convernt points to geoms

First, let's this straight. If all you need to do make a scatterplot, just make one the standard way with ggplot2's standard functions. However, if you have reason to make points with ggpathdiagramr and then plot them, then `as.geom` function can help.

The `as.geom` function is called implicitly whenever a point or point list is added to a ggplot.

```{r}
ggplot() + 
  pts
```

This is equivalent to 

```{r}
ggplot() +
  as.geom(pts)
```

And this is equivalent to 

```{r}
ggplot() +
  geom_point(
    aes(
      x,
      y,
      color = I(color),
      shape = I(shape),
      size = I(size)), 
    data = get_tibble_defaults(pts))
```

That is, any style information will be handled via the `I` (identity) function in the mapping statement (`aes`).

Calling the `as.geom` function directly is useful for overriding any style information in the points. 

```{r}
ggplot() + 
  as.geom(pts, 
          stroke = 1.5,
          fill = "yellow", 
          shape = "triangle filled")
```

This is equivalent to 

```{r}
ggplot() +
  geom_point(
    aes(x = x, 
        y = y, 
        size = I(size), 
        color = I(color)),
    stroke = 1.5,
    fill = "yellow",
    shape = "triangle filled",
    data = get_tibble_defaults(pts)
  )
```









